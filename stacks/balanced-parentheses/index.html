<!DOCTYPE html>
<html>
<head>
  <title>Balanced Parentheses</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/png" href="http://bradfield.institute/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/0.0.1/prism.min.css">
  <link rel="stylesheet" href="/algos/book.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.10/d3.min.js"></script>
  <script src="/algos/language-switching.js"></script>
  <script src="/algos/figures.js"></script>

</head>
<body>



  
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  


<div class="container">

  <div class="page">
    <div class="content">
      <h1>
        Balanced Parentheses
        <select id="language-switcher"></select>
      </h1>
      <p>We now turn our attention to using stacks to solve real computer science
problems. You have no doubt written arithmetic expressions such as</p>
<p><div class="katex-block"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mn>5</mn><mo>+</mo><mn>6</mn><mo>)</mo><mo>×</mo><mo>(</mo><mn>7</mn><mo>+</mo><mn>8</mn><mo>)</mo><mi mathvariant="normal">/</mi><mo>(</mo><mn>4</mn><mo>+</mo><mn>3</mn><mo>)</mo></mrow><annotation encoding="application/x-tex"> (5+6)\times(7+8)/(4+3) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathrm">5</span><span class="mbin">+</span><span class="mord mathrm">6</span><span class="mclose">)</span><span class="mbin">×</span><span class="mopen">(</span><span class="mord mathrm">7</span><span class="mbin">+</span><span class="mord mathrm">8</span><span class="mclose">)</span><span class="mord mathrm">/</span><span class="mopen">(</span><span class="mord mathrm">4</span><span class="mbin">+</span><span class="mord mathrm">3</span><span class="mclose">)</span></span></span></span></div>
where parentheses are used to order the performance of operations. You
may also have some experience programming in a language such as Lisp
with constructs like</p>
<pre><code class="lang-lisp">(defun square(n)
     (* n n))
</code></pre>
<p>This defines a function called <code>square</code> that will return the square of
its argument <code>n</code>. Lisp is notorious for using lots and lots of
parentheses.</p>
<p>In both of these examples, parentheses must appear in a balanced
fashion. <em>Balanced parentheses</em> means that each opening symbol has a
corresponding closing symbol and the pairs of parentheses are properly
nested. Consider the following correctly balanced strings of
parentheses:</p>
<pre><code>(()()()())

(((())))

(()((())()))
</code></pre><p>Compare those with the following, which are not balanced:</p>
<pre><code>((((((())

()))

(()()(()
</code></pre><p>The ability to differentiate between parentheses that are correctly
balanced and those that are unbalanced is an important part of
recognizing many programming language structures.</p>
<p>The challenge then is to write an algorithm that will read a string of
parentheses from left to right and decide whether the symbols are
balanced. To solve this problem we need to make an important
observation. As you process symbols from left to right, the most recent
opening parenthesis must match the next closing symbol. Also, the first
opening symbol processed may have to wait until the very last symbol for
its match. Closing symbols match opening symbols in the reverse order of
their appearance; they match from the inside out. This is a clue that
stacks can be used to solve the problem.</p>
<p>
  <figure>
    <img src="figures/simple-parity-check.png" alt="Matching parentheses">
    <figcaption>Matching parentheses</figcaption>
  </figure></p>
<p>Once you agree that a stack is the appropriate data structure for
keeping the parentheses, the statement of the algorithm is
straightforward. Starting with an empty stack, process the parenthesis
strings from left to right. If a symbol is an opening parenthesis, push
it on the stack as a signal that a corresponding closing symbol needs to
appear later. If, on the other hand, a symbol is a closing parenthesis,
pop the stack. As long as it is possible to pop the stack to match every
closing symbol, the parentheses remain balanced. If at any time there is
no opening symbol on the stack to match a closing symbol, the string is
not balanced properly. At the end of the string, when all symbols have
been processed, the stack should be empty. The Python code to implement
this algorithm may look like this:</p>
  <pre><code class="language-python">OPENING <span class="token operator" >=</span> <span class="token string" >'('</span>


<span class="token keyword" >def</span> <span class="token function" >is_balanced</span><span class="token punctuation" >(</span>parentheses<span class="token punctuation" >)</span><span class="token punctuation" >:</span>
    stack <span class="token operator" >=</span> <span class="token punctuation" >[</span><span class="token punctuation" >]</span>
    <span class="token keyword" >for</span> paren <span class="token keyword" >in</span> parentheses<span class="token punctuation" >:</span>
        <span class="token keyword" >if</span> paren <span class="token operator" >==</span> OPENING<span class="token punctuation" >:</span>
            stack<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>paren<span class="token punctuation" >)</span>
        <span class="token keyword" >else</span><span class="token punctuation" >:</span>
            <span class="token keyword" >try</span><span class="token punctuation" >:</span>
                stack<span class="token punctuation" >.</span>pop<span class="token punctuation" >(</span><span class="token punctuation" >)</span>
            <span class="token keyword" >except</span> IndexError<span class="token punctuation" >:</span>  <span class="token comment" spellcheck="true"># too many closing parens</span>
                <span class="token keyword" >return</span> <span class="token boolean" >False</span>
    <span class="token keyword" >return</span> len<span class="token punctuation" >(</span>stack<span class="token punctuation" >)</span> <span class="token operator" >==</span> <span class="token number" >0</span>  <span class="token comment" spellcheck="true"># false if too many opening parens</span>


is_balanced<span class="token punctuation" >(</span><span class="token string" >'((()))'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => True</span>
is_balanced<span class="token punctuation" >(</span><span class="token string" >'(()'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => False</span>
is_balanced<span class="token punctuation" >(</span><span class="token string" >'())'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => False</span>
</code></pre>


<p>This function, <code>is_balanced</code>, returns a boolean result as to whether the
string of parentheses is balanced. If the current symbol is <code>(</code>, then it
is pushed on the stack. If it is <code>)</code> we attempt to pop from the stack.
If the stack is empty at that point, we know that the parenthesis string
is imbalanced with too many closing parens. Finally, as long as the
expression is balanced and the stack has been completely cleaned off,
the string represents a correctly balanced sequence of parentheses.</p>
<h2 id="balanced-symbols-a-general-case">Balanced Symbols: A General Case</h2>
<p>The balanced parentheses problem shown above is a specific case of a
more general situation that arises in many programming languages. The
general problem of balancing and nesting different kinds of opening and
closing symbols occurs frequently. For example, in Python square
brackets, <code>[</code> and <code>]</code>, are used for lists; curly braces, <code>{</code> and <code>}</code>,
are used for dictionaries; and parentheses, <code>(</code> and <code>)</code>, are used for
tuples and arithmetic expressions. It is possible to mix symbols as long
as each maintains its own open and close relationship. Strings of
symbols such as</p>
<pre><code>{ { ( [ ] [ ] ) } ( ) }

[ [ { { ( ( ) ) } } ] ]

[ ] [ ] [ ] ( ) { }
</code></pre><p>are properly balanced in that not only does each opening symbol have a
corresponding closing symbol, but the types of symbols match as well.</p>
<p>Compare those with the following strings that are not balanced:</p>
<pre><code>( [ ) ]

( ( ( ) ] ) )

[ { ( ) ]
</code></pre><p>The simple parentheses checker from the previous section can easily be
extended to handle these new types of symbols. Recall that each opening
symbol is simply pushed on the stack to wait for the matching closing
symbol to appear later in the sequence. When a closing symbol does
appear, the only difference is that we must check to be sure that it
correctly matches the type of the opening symbol on top of the stack. If
the two symbols do not match, the string is not balanced. Once again, if
the entire string is processed and nothing is left on the stack, the
string is correctly balanced.</p>
<p>The Python program to implement this is shown below. The only change is
that we use a dictionary to ensure that symbols popped from the stack
correctly match our expectations of pairing with the symbol being
considered at the time.</p>
  <pre><code class="language-python">PAIRINGS <span class="token operator" >=</span> <span class="token punctuation" >{</span>
    <span class="token string" >'('</span><span class="token punctuation" >:</span> <span class="token string" >')'</span><span class="token punctuation" >,</span>
    <span class="token string" >'{'</span><span class="token punctuation" >:</span> <span class="token string" >'}'</span><span class="token punctuation" >,</span>
    <span class="token string" >'['</span><span class="token punctuation" >:</span> <span class="token string" >']'</span>
<span class="token punctuation" >}</span>


<span class="token keyword" >def</span> <span class="token function" >is_balanced</span><span class="token punctuation" >(</span>symbols<span class="token punctuation" >)</span><span class="token punctuation" >:</span>
    stack <span class="token operator" >=</span> <span class="token punctuation" >[</span><span class="token punctuation" >]</span>
    <span class="token keyword" >for</span> s <span class="token keyword" >in</span> symbols<span class="token punctuation" >:</span>
        <span class="token keyword" >if</span> s <span class="token keyword" >in</span> PAIRINGS<span class="token punctuation" >.</span>keys<span class="token punctuation" >(</span><span class="token punctuation" >)</span><span class="token punctuation" >:</span>
            stack<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>s<span class="token punctuation" >)</span>
            <span class="token keyword" >continue</span>
        <span class="token keyword" >try</span><span class="token punctuation" >:</span>
            expected_opening_symbol <span class="token operator" >=</span> stack<span class="token punctuation" >.</span>pop<span class="token punctuation" >(</span><span class="token punctuation" >)</span>
        <span class="token keyword" >except</span> IndexError<span class="token punctuation" >:</span>  <span class="token comment" spellcheck="true"># too many closing symbols</span>
            <span class="token keyword" >return</span> <span class="token boolean" >False</span>
        <span class="token keyword" >if</span> s <span class="token operator" >!=</span> PAIRINGS<span class="token punctuation" >[</span>expected_opening_symbol<span class="token punctuation" >]</span><span class="token punctuation" >:</span>  <span class="token comment" spellcheck="true"># mismatch</span>
            <span class="token keyword" >return</span> <span class="token boolean" >False</span>
    <span class="token keyword" >return</span> len<span class="token punctuation" >(</span>stack<span class="token punctuation" >)</span> <span class="token operator" >==</span> <span class="token number" >0</span>  <span class="token comment" spellcheck="true"># false if too many opening symbols</span>


is_balanced<span class="token punctuation" >(</span><span class="token string" >'{{([][])}()}'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => True</span>
is_balanced<span class="token punctuation" >(</span><span class="token string" >'{[])'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => False</span>
is_balanced<span class="token punctuation" >(</span><span class="token string" >'((()))'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => True</span>
is_balanced<span class="token punctuation" >(</span><span class="token string" >'(()'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => False</span>
is_balanced<span class="token punctuation" >(</span><span class="token string" >'())'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => False</span>
</code></pre>


<p>These two examples show that stacks are very important data structures
for the processing of language constructs in computer science. Almost
any notation you can think of has some type of nested symbol that must
be matched in a balanced order. There are a number of other important
uses for stacks in computer science. We will continue to explore them in
the next sections.</p>


      <div class="navigation">
        
          Next:
          <a href="/algos/stacks/converting-number-bases">
            Converting Number Bases
          </a>
        
        
      </div>
    </div>
  </div>

  <div class="table-of-contents">
    <h1>Practical Algorithms and&nbsp;Data&nbsp;Structures</h2>
    <a href="/algos/">Introduction</a>

    <div class="chapters">
      
        
        <div class="chapter">
          <h2>Analysis</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/analysis/introduction">Introduction to Algorithm Analysis</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/analysis/big-o-notation">Big O Notation</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/analysis/an-anagram-detection-example">An Anagram Detection Example</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/analysis/performance-of-python-types">Performance of Python Types</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Stacks</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/stacks/introduction">Introduction to Stacks</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/stacks/implementation">A Stack Implementation</a>
              
            </li>
          
            
            <li>
              
                
                Balanced Parentheses
              
            </li>
          
            
            <li>
              
                <a href="/algos/stacks/converting-number-bases">Converting Number Bases</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/stacks/infix-prefix-and-postfix-expressions">Infix, Prefix and Postfix Expressions</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Queues</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/queues/introduction">Introduction to Queues</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/queues/implementation">A Queue Implementation</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/queues/simulating-hot-potato">Simulating Hot Potato</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Deques</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/deques/implementation">A Deque Implementation</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/deques/palindrome-checker">Palindrome Checker</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Lists</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/lists/introduction">Introduction to Lists</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/lists/implementing-an-unordered-list">Implementing an Unordered List</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/lists/implementing-an-ordered-list">Implementing an Ordered List</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Recursion</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/recursion/introduction">Introduction to Recursion</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/calculating-the-sum-of-a-list-of-numbers">Calculating the Sum of a List of Numbers</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/the-three-laws-of-recursion">The Three Laws of Recursion</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/converting-an-integer-to-a-string">Converting an Integer to Any Base</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/tower-of-hanoi">Tower of Hanoi</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/dynamic-programming">Dynamic Programming</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Searching</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/searching/searching">Searching</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/searching/the-sequential-search">The Sequential Search</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/searching/the-binary-search">The Binary Search</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/searching/hashing">Hashing</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Trees</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/trees/introduction">Introduction to Trees</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/representing-a-tree">Representing a Tree</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/parse-trees">Parse Trees</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/tree-traversals">Tree Traversals</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/priority-queues-with-binary-heaps">Priority Queues with Binary Heaps</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/binary-search-trees">Binary Search Trees</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/avl-trees">AVL Trees</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Graphs</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/graphs/introduction">Introduction to Graphs</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/representing-a-graph">Representing a Graph</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/word-ladder">Word Ladders</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/knights-tour">A Knight’s Tour</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/depth-first-search">General Depth First Search</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/topological-sorting">Topological Sorting</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/dijkstras-algorithm">Shortest Path with Dijkstra’s Algorithm</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/strongly-connected-components">Strongly Connected Components</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/prims-spanning-tree-algorithm">Prim’s Spanning Tree Algorithm</a>
              
            </li>
          
          </ol>
        </div>
      
    </div>

  </div>

</div><!-- .container -->

<svg id="svg-refs">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="10" refx="0" refy="3" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L0,6 L9,3 z" fill="context-stroke" />
    </marker>
  </defs>
</svg>

<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-71655366-1', 'auto');
ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

</body>
</html>
