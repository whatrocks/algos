<!DOCTYPE html>
<html>
<head>
  <title>Infix, Prefix and Postfix Expressions</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/png" href="http://bradfield.institute/favicon.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.3.0/katex.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/0.0.1/prism.min.css">
  <link rel="stylesheet" href="/algos/book.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.10/d3.min.js"></script>
  <script src="/algos/language-switching.js"></script>
  <script src="/algos/figures.js"></script>

</head>
<body>



  
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  

  
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  
    
    
  


<div class="container">

  <div class="page">
    <div class="content">
      <h1>
        Infix, Prefix and Postfix Expressions
        <select id="language-switcher"></select>
      </h1>
      <p>When you write an arithmetic expression such as <code>B * C</code>, the form of the
expression provides you with information so that you can interpret it
correctly. In this case we know that the variable <code>B</code> is being multiplied
by the variable <code>C</code> since the multiplication operator <code>*</code> appears between
them in the expression. This type of notation is referred to as
<em>infix</em> since the operator is <em>in between</em> the two operands that it is
working on.</p>
<p>Consider another infix example, <code>A + B * C</code>. The operators + and *
still appear between the operands, but there is a problem. Which
operands do they work on? Does the <code>+</code> work on <code>A</code> and <code>B</code> or does the
<code>*</code> take <code>B</code> and <code>C</code>? The expression seems ambiguous.</p>
<p>In fact, you have been reading and writing these types of expressions
for a long time and they do not cause you any problem. The reason for
this is that you know something about the operators <code>+</code> and <code>*</code>. Each
operator has a <em>precedence</em> level. Operators of higher precedence are
used before operators of lower precedence. The only thing that can
change that order is the presence of parentheses. The precedence order
for arithmetic operators places multiplication and division above
addition and subtraction. If two operators of equal precedence appear,
then a left-to-right ordering or associativity is used.</p>
<p>Let’s interpret the troublesome expression <code>A + B * C</code> using operator
precedence. <code>B</code> and <code>C</code> are multiplied first, and <code>A</code> is then added to that
result. <code>(A + B) * C</code> would force the addition of <code>A</code> and <code>B</code> to be done
first before the multiplication. In expression <code>A + B + C</code>, by precedence
(via associativity), the leftmost <code>+</code> would be done first.</p>
<p>Although all this may be obvious to you, remember that computers need to
know exactly what operators to perform and in what order. One way to
write an expression that guarantees there will be no confusion with
respect to the order of operations is to create what is called a <em>fully
parenthesized</em> expression. This type of expression uses one pair of
parentheses for each operator. The parentheses dictate the order of
operations; there is no ambiguity. There is also no need to remember any
precedence rules.</p>
<p>The expression <code>A + B * C + D</code> can be rewritten as <code>((A + (B * C)) + D)</code>
to show that the multiplication happens first, followed by the leftmost
addition. <code>A + B + C + D</code> can be written as <code>(((A + B) + C) + D)</code> since the
addition operations associate from left to right.</p>
<p>There are two other very important expression formats that may not seem
obvious to you at first. Consider the infix expression <code>A + B</code>. What would
happen if we moved the operator before the two operands? The resulting
expression would be <code>+ A B</code>. Likewise, we could move the operator to the
end. We would get <code>A B +</code>. These look a bit strange.</p>
<p>These changes to the position of the operator with respect to the
operands create two new expression formats, <em>prefix</em> and <em>postfix</em>.
Prefix expression notation requires that all operators precede the two
operands that they work on. Postfix, on the other hand, requires that
its operators come after the corresponding operands. A few more examples
should help to make this a bit clearer:</p>
<table>
<thead>
<tr>
<th>Infix expression</th>
<th>Prefix expression</th>
<th>Postfix expression</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A + B</code></td>
<td><code>+ A B</code></td>
<td><code>A B +</code></td>
</tr>
<tr>
<td><code>A + B * C</code></td>
<td><code>+ A * B C</code></td>
<td><code>A B C * +</code></td>
</tr>
</tbody>
</table>
<p><code>A + B * C</code> would be written as <code>+ A * B C</code> in prefix. The
multiplication operator comes immediately before the operands <code>B</code> and
<code>C</code>, denoting that <code>*</code> has precedence over <code>+</code>. The addition operator
then appears before the <code>A</code> and the result of the multiplication.</p>
<p>In postfix, the expression would be <code>A B C * +</code>. Again, the order of
operations is preserved since the <code>*</code> appears immediately after the <code>B</code> and
the <code>C</code>, denoting that <code>*</code> has precedence, with <code>+</code> coming after. Although
the operators moved and now appear either before or after their
respective operands, the order of the operands stayed exactly the same
relative to one another.</p>
<p>Now consider the infix expression <code>(A + B) * C</code>. Recall that in this
case, infix requires the parentheses to force the performance of the
addition before the multiplication. However, when <code>A + B</code> was written in
prefix, the addition operator was simply moved before the operands, <code>+ A
B</code>. The result of this operation becomes the first operand for the
multiplication. The multiplication operator is moved in front of the
entire expression, giving us <code>* + A B C</code>. Likewise, in postfix <code>A B +</code>
forces the addition to happen first. The multiplication can be done to
that result and the remaining operand <code>C</code>. The proper postfix expression
is then <code>A B + C *</code>.</p>
<p>Consider these three expressions again. Something very important has
happened. Where did the parentheses go? Why don’t we need them in prefix
and postfix? The answer is that the operators are no longer ambiguous
with respect to the operands that they work on. Only infix notation
requires the additional symbols. The order of operations within prefix
and postfix expressions is completely determined by the position of the
operator and nothing else. In many ways, this makes infix the least
desirable notation to use.</p>
<table>
<thead>
<tr>
<th>Infix expression</th>
<th>Prefix expression</th>
<th>Postfix expression</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>(A + B) * C</code></td>
<td><code>* + A B C</code></td>
<td><code>A B + C *</code></td>
</tr>
</tbody>
</table>
<p>The table below shows some additional examples of infix
expressions and the equivalent prefix and postfix expressions. Be sure
that you understand how they are equivalent in terms of the order of the
operations being performed.</p>
<table>
<thead>
<tr>
<th>Infix expression</th>
<th>Prefix expression</th>
<th>Postfix expression</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>A + B * C + D</code></td>
<td><code>+ + A * B C D</code></td>
<td><code>A B C * + D +</code></td>
</tr>
<tr>
<td><code>(A + B) * (C + D)</code></td>
<td><code>* + A B + C D</code></td>
<td><code>A B + C D + *</code></td>
</tr>
<tr>
<td><code>A * B + C * D</code></td>
<td><code>+ * A B * C D</code></td>
<td><code>A B * C D * +</code></td>
</tr>
<tr>
<td><code>A + B + C + D</code></td>
<td><code>+ + + A B C D</code></td>
<td><code>A B + C + D +</code></td>
</tr>
</tbody>
</table>
<h2 id="conversion-of-infix-expressions-to-prefix-and-postfix">Conversion of Infix Expressions to Prefix and Postfix</h2>
<p>So far, we have used ad hoc methods to convert between infix expressions
and the equivalent prefix and postfix expression notations. As you might
expect, there are algorithmic ways to perform the conversion that allow
any expression of any complexity to be correctly transformed.</p>
<p>The first technique that we will consider uses the notion of a fully
parenthesized expression that was discussed earlier. Recall that <code>A + B * C</code>
can be written as <code>(A + (B * C))</code> to show explicitly that the
multiplication has precedence over the addition. On closer observation,
however, you can see that each parenthesis pair also denotes the
beginning and the end of an operand pair with the corresponding operator
in the middle.</p>
<p>Look at the right parenthesis in the subexpression <code>(B * C)</code> above. If we
were to move the multiplication symbol to that position and remove the
matching left parenthesis, giving us <code>B C *</code>, we would in effect have
converted the subexpression to postfix notation. If the addition
operator were also moved to its corresponding right parenthesis position
and the matching left parenthesis were removed, the complete postfix
expression would result.</p>
<p>
  <figure>
    <img src="figures/move-right.png" alt="Moving operators to the right for postfix notation">
    <figcaption>Moving operators to the right for postfix notation</figcaption>
  </figure></p>
<p>If we do the same thing but instead of moving the symbol to the position
of the right parenthesis, we move it to the left, we get prefix notation
(below). The position of the parenthesis pair is actually a clue to the
final position of the enclosed operator.</p>
<p>
  <figure>
    <img src="figures/move-left.png" alt="Moving operators to the left for prefix notation">
    <figcaption>Moving operators to the left for prefix notation</figcaption>
  </figure></p>
<p>So in order to convert an expression, no matter how complex, to either
prefix or postfix notation, fully parenthesize the expression using the
order of operations. Then move the enclosed operator to the position of
either the left or the right parenthesis depending on whether you want
prefix or postfix notation.</p>
<p>Here is a more complex expression: <code>(A + B) * C - (D - E) * (F + G)</code>:</p>
<p>
  <figure>
    <img src="figures/complex-move.png" alt="Converting a complex expression to prefix and postfix notations">
    <figcaption>Converting a complex expression to prefix and postfix notations</figcaption>
  </figure></p>
<h2 id="general-infix-to-postfix-conversion">General Infix-to-Postfix Conversion</h2>
<p>We need to develop an algorithm to convert any infix expression to a
postfix expression. To do this we will look closer at the conversion
process.</p>
<p>Consider once again the expression <code>A + B * C</code>. As shown above, <code>A B C *
+</code> is the postfix equivalent. We have already noted that the operands
<code>A</code>, <code>B</code>, and <code>C</code> stay in their relative positions. It is only the
operators that change position. Let’s look again at the operators in the
infix expression. The first operator that appears from left to right is
<code>+</code>. However, in the postfix expression, <code>+</code> is at the end since the
next operator, <code>*</code>, has precedence over addition. The order of the
operators in the original expression is reversed in the resulting
postfix expression.</p>
<p>As we process the expression, the operators have to be saved somewhere
since their corresponding right operands are not seen yet. Also, the
order of these saved operators may need to be reversed due to their
precedence. This is the case with the addition and the multiplication in
this example. Since the addition operator comes before the
multiplication operator and has lower precedence, it needs to appear
after the multiplication operator is used. Because of this reversal of
order, it makes sense to consider using a stack to keep the operators
until they are needed.</p>
<p>What about <code>(A + B) * C</code>? Recall that <code>A B + C *</code> is the postfix
equivalent. Again, processing this infix expression from left to right,
we see <code>+</code> first. In this case, when we see <code>*</code>, <code>+</code> has already been placed
in the result expression because it has precedence over <code>*</code> by virtue of
the parentheses. We can now start to see how the conversion algorithm
will work. When we see a left parenthesis, we will save it to denote
that another operator of high precedence will be coming. That operator
will need to wait until the corresponding right parenthesis appears to
denote its position (recall the fully parenthesized technique). When
that right parenthesis does appear, the operator can be popped from the
stack.</p>
<p>As we scan the infix expression from left to right, we will use a stack
to keep the operators. This will provide the reversal that we noted in
the first example. The top of the stack will always be the most recently
saved operator. Whenever we read a new operator, we will need to
consider how that operator compares in precedence with the operators, if
any, already on the stack.</p>
<p>Assume the infix expression is a string of tokens delimited by spaces.
The operator tokens are <code>*</code>, <code>/</code>, <code>+</code>, and <code>-</code>, along with the left and right
parentheses, <code>(</code> and <code>)</code>. The operand tokens are the single-character
identifiers <code>A</code>, <code>B</code>, <code>C</code>, and so on. The following steps will produce a
string of tokens in postfix order.</p>
<ol>
<li>Create an empty stack called <code>operation_stack</code> for keeping operators. Create
an empty list for output.</li>
<li>Convert the input infix string to a list by using the string method
<code>split</code>.</li>
<li><p>Scan the token list from left to right.</p>
<ul>
<li>If the token is an operand, append it to the end of the
output list.</li>
<li>If the token is a left parenthesis, push it on the <code>operation_stack</code>.</li>
<li>If the token is a right parenthesis, pop the <code>operation_stack</code> until the
corresponding left parenthesis is removed. Append each operator
to the end of the output list.</li>
<li>If the token is an operator, <code>*</code>, <code>/</code>, <code>+</code>, or <code>-</code>, push it on the
<code>operation_stack</code>. However, first remove any operators already on the
<code>operation_stack</code> that have higher or equal precedence and append them
to the output list.</li>
</ul>
</li>
<li><p>When the input expression has been completely processed, check the
<code>operation_stack</code>. Any operators still on the stack can be removed and
appended to the end of the output list.</p>
</li>
</ol>
<p>Below we show the conversion algorithm working on
the expression <code>A * B + C * D</code>. Note that the first <code>*</code> operator is
removed upon seeing the <code>+</code> operator. Also, <code>+</code> stays on the stack when the
second <code>*</code> occurs, since multiplication has precedence over addition. At
the end of the infix expression the stack is popped twice, removing both
operators and placing + as the last operator in the postfix expression.</p>
<p>
  <figure>
    <img src="figures/into-postfix.png" alt="Converting `A * B + C * D` to postfix notation">
    <figcaption>Converting `A * B + C * D` to postfix notation</figcaption>
  </figure></p>
<p>In order to code the algorithm in Python, we will use a dictionary
called <code>precedence</code> to hold the precedence values for the operators. This
dictionary will map each operator to an integer that can be compared
against the precedence levels of other operators (we have arbitrarily
used the integers 3, 2, and 1). The left parenthesis will receive the
lowest value possible. This way any operator that is compared against it
will have higher precedence and will be placed on top of it.</p>
  <pre><code class="language-python">PRECEDENCE <span class="token operator" >=</span> <span class="token punctuation" >{</span>
    <span class="token string" >'*'</span><span class="token punctuation" >:</span> <span class="token number" >3</span><span class="token punctuation" >,</span>
    <span class="token string" >'/'</span><span class="token punctuation" >:</span> <span class="token number" >3</span><span class="token punctuation" >,</span>
    <span class="token string" >'+'</span><span class="token punctuation" >:</span> <span class="token number" >2</span><span class="token punctuation" >,</span>
    <span class="token string" >'-'</span><span class="token punctuation" >:</span> <span class="token number" >2</span><span class="token punctuation" >,</span>
    <span class="token string" >'('</span><span class="token punctuation" >:</span> <span class="token number" >1</span>
<span class="token punctuation" >}</span>

CHARACTERS <span class="token operator" >=</span> <span class="token string" >'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span>
DIGITS <span class="token operator" >=</span> <span class="token string" >'0123456789'</span>
LEFT_PAREN <span class="token operator" >=</span> <span class="token string" >'('</span>
RIGHT_PAREN <span class="token operator" >=</span> <span class="token string" >')'</span>


<span class="token keyword" >def</span> <span class="token function" >infix_to_postfix</span><span class="token punctuation" >(</span>infix_expression<span class="token punctuation" >)</span><span class="token punctuation" >:</span>
    operation_stack <span class="token operator" >=</span> <span class="token punctuation" >[</span><span class="token punctuation" >]</span>
    postfix <span class="token operator" >=</span> <span class="token punctuation" >[</span><span class="token punctuation" >]</span>
    tokens <span class="token operator" >=</span> infix_expression<span class="token punctuation" >.</span>split<span class="token punctuation" >(</span><span class="token punctuation" >)</span>

    <span class="token keyword" >for</span> token <span class="token keyword" >in</span> tokens<span class="token punctuation" >:</span>
        <span class="token keyword" >if</span> token <span class="token keyword" >in</span> CHARACTERS <span class="token operator" >or</span> token <span class="token keyword" >in</span> DIGITS<span class="token punctuation" >:</span>
            postfix<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>token<span class="token punctuation" >)</span>
        <span class="token keyword" >elif</span> token <span class="token operator" >==</span> LEFT_PAREN<span class="token punctuation" >:</span>
            operation_stack<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>token<span class="token punctuation" >)</span>
        <span class="token keyword" >elif</span> token <span class="token operator" >==</span> RIGHT_PAREN<span class="token punctuation" >:</span>
            top_token <span class="token operator" >=</span> operation_stack<span class="token punctuation" >.</span>pop<span class="token punctuation" >(</span><span class="token punctuation" >)</span>
            <span class="token keyword" >while</span> top_token <span class="token operator" >!=</span> LEFT_PAREN<span class="token punctuation" >:</span>
                postfix<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>top_token<span class="token punctuation" >)</span>
                top_token <span class="token operator" >=</span> operation_stack<span class="token punctuation" >.</span>pop<span class="token punctuation" >(</span><span class="token punctuation" >)</span>
        <span class="token keyword" >else</span><span class="token punctuation" >:</span>
            <span class="token keyword" >while</span> operation_stack <span class="token operator" >and</span> \
                    <span class="token punctuation" >(</span>PRECEDENCE<span class="token punctuation" >[</span>operation_stack<span class="token punctuation" >[</span><span class="token operator" >-</span><span class="token number" >1</span><span class="token punctuation" >]</span><span class="token punctuation" >]</span> <span class="token operator" >>=</span> PRECEDENCE<span class="token punctuation" >[</span>token<span class="token punctuation" >]</span><span class="token punctuation" >)</span><span class="token punctuation" >:</span>
                postfix<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>operation_stack<span class="token punctuation" >.</span>pop<span class="token punctuation" >(</span><span class="token punctuation" >)</span><span class="token punctuation" >)</span>
            operation_stack<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>token<span class="token punctuation" >)</span>

    <span class="token keyword" >while</span> operation_stack<span class="token punctuation" >:</span>
        postfix<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>operation_stack<span class="token punctuation" >.</span>pop<span class="token punctuation" >(</span><span class="token punctuation" >)</span><span class="token punctuation" >)</span>
    <span class="token keyword" >return</span> <span class="token string" >' '</span><span class="token punctuation" >.</span>join<span class="token punctuation" >(</span>postfix<span class="token punctuation" >)</span>

infix_to_postfix<span class="token punctuation" >(</span><span class="token string" >'A * B + C * D'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => 'A B * C D * +'</span>
infix_to_postfix<span class="token punctuation" >(</span><span class="token string" >'( A + B ) * C - ( D - E ) * ( F + G )'</span><span class="token punctuation" >)</span>
<span class="token comment" spellcheck="true"># => 'A B + C * D E - F G + * -'</span>
infix_to_postfix<span class="token punctuation" >(</span><span class="token string" >'( A + B ) * ( C + D )'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => 'A B + C D + *'</span>
infix_to_postfix<span class="token punctuation" >(</span><span class="token string" >'( A + B ) * C'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => 'A B + C *'</span>
infix_to_postfix<span class="token punctuation" >(</span><span class="token string" >'A + B * C'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => 'A B C * +'</span>
</code></pre>


<h2 id="postfix-evaluation">Postfix Evaluation</h2>
<p>As a final stack example, we will consider the evaluation of an
expression that is already in postfix notation. In this case, a stack is
again the data structure of choice. However, as you scan the postfix
expression, it is the operands that must wait, not the operators as in
the conversion algorithm above. Another way to think about the solution
is that whenever an operator is seen on the input, the two most recent
operands will be used in the evaluation.</p>
<p>To see this in more detail, consider the postfix expression <code>4 5 6 * +</code>.
As you scan the expression from left to right, you first encounter the
operands 4 and 5. At this point, you are still unsure what to do with
them until you see the next symbol. Placing each on the stack ensures
that they are available if an operator comes next.</p>
<p>In this case, the next symbol is another operand. So, as before, push it
and check the next symbol. Now we see an operator, <code>*</code>. This means that
the two most recent operands need to be used in a multiplication
operation. By popping the stack twice, we can get the proper operands
and then perform the multiplication (in this case getting the result
30).</p>
<p>We can now handle this result by placing it back on the stack so that it
can be used as an operand for the later operators in the expression.
When the final operator is processed, there will be only one value left
on the stack. Pop and return it as the result of the expression.
Below we show the stack contents as this entire example expression is being processed.</p>
<p>
  <figure>
    <img src="figures/evaluate-postfix-1.png" alt="Stack contents during evaluation">
    <figcaption>Stack contents during evaluation</figcaption>
  </figure></p>
<p>Below we show a slightly more complex example,
<code>7 8 + 3 2 + /</code>. There are two things to note in this example. First, the
stack size grows, shrinks, and then grows again as the subexpressions
are evaluated. Second, the division operation needs to be handled
carefully. Recall that the operands in the postfix expression are in
their original order since postfix changes only the placement of
operators. When the operands for the division are popped from the stack,
they are reversed. Since division is <em>not</em> a commutative operator, in
other words <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>5</mn><mi mathvariant="normal">/</mi><mn>5</mn></mrow><annotation encoding="application/x-tex">15/5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">1</span><span class="mord mathrm">5</span><span class="mord mathrm">/</span><span class="mord mathrm">5</span></span></span></span> is not the same as <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>5</mn><mi mathvariant="normal">/</mi><mn>1</mn><mn>5</mn></mrow><annotation encoding="application/x-tex">5/15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">5</span><span class="mord mathrm">/</span><span class="mord mathrm">1</span><span class="mord mathrm">5</span></span></span></span>, we must be sure that the
order of the operands is not switched.</p>
<p>
  <figure>
    <img src="figures/evaluate-postfix-2.png" alt="A more complex example of evaluation">
    <figcaption>A more complex example of evaluation</figcaption>
  </figure></p>
<p>Assume the postfix expression is a string of tokens delimited by spaces.
The operators are <code>*</code>, <code>/</code>, <code>+</code>, and <code>-</code> and the operands are assumed to be
single-digit integer values. The output will be an integer result.</p>
<ol>
<li>Create an empty stack called <code>operand_stack</code>.</li>
<li>Convert the string to a list by using the string method <code>split</code>.</li>
<li><p>Scan the token list from left to right.</p>
<ul>
<li>If the token is an operand, convert it from a string to an
integer and push the value onto the <code>operand_stack</code>.</li>
<li>If the token is an operator, <code>*</code>, <code>/</code>, <code>+</code>, or <code>-</code>, it will need
two operands. Pop the <code>operand_stack</code> twice. The first pop is the
second operand and the second pop is the first operand. Perform
the arithmetic operation. Push the result back on the
<code>operand_stack</code>.</li>
</ul>
</li>
<li><p>When the input expression has been completely processed, the result
is on the stack. Pop the <code>operand_stack</code> and return the value.</p>
</li>
</ol>
<p>The complete function for the evaluation of postfix expressions is shown
below. To assist with the arithmetic, we importer the handy <code>operator</code>
module from the Python standard library to specify functions that will
take two arguments and return the result of the proper arithmetic
operation.</p>
  <pre><code class="language-python"><span class="token keyword" >import</span> operator

OPERATION <span class="token operator" >=</span> <span class="token punctuation" >{</span>
    <span class="token string" >'*'</span><span class="token punctuation" >:</span> operator<span class="token punctuation" >.</span>mul<span class="token punctuation" >,</span>
    <span class="token string" >'/'</span><span class="token punctuation" >:</span> operator<span class="token punctuation" >.</span>div<span class="token punctuation" >,</span>
    <span class="token string" >'-'</span><span class="token punctuation" >:</span> operator<span class="token punctuation" >.</span>sub<span class="token punctuation" >,</span>
    <span class="token string" >'+'</span><span class="token punctuation" >:</span> operator<span class="token punctuation" >.</span>add
<span class="token punctuation" >}</span>

DIGITS <span class="token operator" >=</span> set<span class="token punctuation" >(</span><span class="token string" >'0123456789'</span><span class="token punctuation" >)</span>


<span class="token keyword" >def</span> <span class="token function" >evaluate_postfix</span><span class="token punctuation" >(</span>postfix_expression<span class="token punctuation" >)</span><span class="token punctuation" >:</span>
    operand_stack <span class="token operator" >=</span> <span class="token punctuation" >[</span><span class="token punctuation" >]</span>

    <span class="token keyword" >for</span> token <span class="token keyword" >in</span> postfix_expression<span class="token punctuation" >.</span>split<span class="token punctuation" >(</span><span class="token punctuation" >)</span><span class="token punctuation" >:</span>
        <span class="token keyword" >if</span> token <span class="token keyword" >in</span> DIGITS<span class="token punctuation" >:</span>
            operand_stack<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>int<span class="token punctuation" >(</span>token<span class="token punctuation" >)</span><span class="token punctuation" >)</span>
        <span class="token keyword" >else</span><span class="token punctuation" >:</span>
            b <span class="token operator" >=</span> operand_stack<span class="token punctuation" >.</span>pop<span class="token punctuation" >(</span><span class="token punctuation" >)</span>
            a <span class="token operator" >=</span> operand_stack<span class="token punctuation" >.</span>pop<span class="token punctuation" >(</span><span class="token punctuation" >)</span>
            result <span class="token operator" >=</span> OPERATION<span class="token punctuation" >[</span>token<span class="token punctuation" >]</span><span class="token punctuation" >(</span>a<span class="token punctuation" >,</span> b<span class="token punctuation" >)</span>
            operand_stack<span class="token punctuation" >.</span>append<span class="token punctuation" >(</span>result<span class="token punctuation" >)</span>
    <span class="token keyword" >return</span> operand_stack<span class="token punctuation" >.</span>pop<span class="token punctuation" >(</span><span class="token punctuation" >)</span>

evaluate_postfix<span class="token punctuation" >(</span><span class="token string" >'7 8 + 3 2 + /'</span><span class="token punctuation" >)</span>  <span class="token comment" spellcheck="true"># => 3.0</span>
</code></pre>


<p>It is important to note that in both the postfix conversion and the
postfix evaluation programs we assumed that there were no errors in the
input expression. Using these programs as a starting point, you can
easily see how error detection and reporting can be included. We leave
this as an exercise.</p>


      <div class="navigation">
        
          Next:
          <a href="/algos/queues/introduction">
            Introduction to Queues
          </a>
        
        
      </div>
    </div>
  </div>

  <div class="table-of-contents">
    <h1>Practical Algorithms and&nbsp;Data&nbsp;Structures</h2>
    <a href="/algos/">Introduction</a>

    <div class="chapters">
      
        
        <div class="chapter">
          <h2>Analysis</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/analysis/introduction">Introduction to Algorithm Analysis</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/analysis/big-o-notation">Big O Notation</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/analysis/an-anagram-detection-example">An Anagram Detection Example</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/analysis/performance-of-python-types">Performance of Python Types</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Stacks</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/stacks/introduction">Introduction to Stacks</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/stacks/implementation">A Stack Implementation</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/stacks/balanced-parentheses">Balanced Parentheses</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/stacks/converting-number-bases">Converting Number Bases</a>
              
            </li>
          
            
            <li>
              
                
                Infix, Prefix and Postfix Expressions
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Queues</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/queues/introduction">Introduction to Queues</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/queues/implementation">A Queue Implementation</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/queues/simulating-hot-potato">Simulating Hot Potato</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Deques</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/deques/implementation">A Deque Implementation</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/deques/palindrome-checker">Palindrome Checker</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Lists</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/lists/introduction">Introduction to Lists</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/lists/implementing-an-unordered-list">Implementing an Unordered List</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/lists/implementing-an-ordered-list">Implementing an Ordered List</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Recursion</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/recursion/introduction">Introduction to Recursion</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/calculating-the-sum-of-a-list-of-numbers">Calculating the Sum of a List of Numbers</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/the-three-laws-of-recursion">The Three Laws of Recursion</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/converting-an-integer-to-a-string">Converting an Integer to Any Base</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/tower-of-hanoi">Tower of Hanoi</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/recursion/dynamic-programming">Dynamic Programming</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Searching</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/searching/searching">Searching</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/searching/the-sequential-search">The Sequential Search</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/searching/the-binary-search">The Binary Search</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/searching/hashing">Hashing</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Trees</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/trees/introduction">Introduction to Trees</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/representing-a-tree">Representing a Tree</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/parse-trees">Parse Trees</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/tree-traversals">Tree Traversals</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/priority-queues-with-binary-heaps">Priority Queues with Binary Heaps</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/binary-search-trees">Binary Search Trees</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/trees/avl-trees">AVL Trees</a>
              
            </li>
          
          </ol>
        </div>
      
        
        <div class="chapter">
          <h2>Graphs</h2>
          <ol>
          
            
            <li>
              
                <a href="/algos/graphs/introduction">Introduction to Graphs</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/representing-a-graph">Representing a Graph</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/word-ladder">Word Ladders</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/knights-tour">A Knight’s Tour</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/depth-first-search">General Depth First Search</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/topological-sorting">Topological Sorting</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/dijkstras-algorithm">Shortest Path with Dijkstra’s Algorithm</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/strongly-connected-components">Strongly Connected Components</a>
              
            </li>
          
            
            <li>
              
                <a href="/algos/graphs/prims-spanning-tree-algorithm">Prim’s Spanning Tree Algorithm</a>
              
            </li>
          
          </ol>
        </div>
      
    </div>

  </div>

</div><!-- .container -->

<svg id="svg-refs">
  <defs>
    <marker id="arrowhead" markerWidth="10" markerHeight="10" refx="0" refy="3" orient="auto" markerUnits="strokeWidth">
      <path d="M0,0 L0,6 L9,3 z" fill="context-stroke" />
    </marker>
  </defs>
</svg>

<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-71655366-1', 'auto');
ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

</body>
</html>
